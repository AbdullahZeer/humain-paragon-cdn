import os
import re
import sys
from collections import defaultdict, deque


def read_file(path: str) -> str:
    with open(path, 'r', encoding='utf-8') as f:
        return f.read()


def write_file(path: str, content: str) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, 'w', encoding='utf-8', newline='\n') as f:
        f.write(content)


def extract_root_block(css: str) -> tuple[str, str, str]:
    """Return (before_root, root_content_inside_braces, after_root)."""
    start = css.find(':root{')
    if start == -1:
        return css, '', ''
    brace_open = start + len(':root{')
    # Find matching single '}' after opening (file is minified; :root is first)
    end = css.find('}', brace_open)
    if end == -1:
        raise ValueError('Unterminated :root block')
    before = css[:start]
    root_inside = css[brace_open:end]
    after = css[end + 1:]
    return before, root_inside, after


def parse_variables(root_inside: str) -> dict[str, str]:
    # Split by ';' and pick '--name: value'
    variables: dict[str, str] = {}
    for chunk in root_inside.split(';'):
        chunk = chunk.strip()
        if not chunk:
            continue
        if not chunk.startswith('--'):
            # ignore non-var or comments
            continue
        if ':' not in chunk:
            continue
        name, value = chunk.split(':', 1)
        variables[name.strip()] = value.strip()
    return variables


def find_dependencies(value: str) -> set[str]:
    # Matches var(--token-name) possibly with fallback
    deps = set(re.findall(r"var\(\s*--([\w-]+)", value))
    # Normalize to variable syntax with leading '--'
    return {f'--{d}' for d in deps}


def topo_order(variables: dict[str, str]) -> list[str]:
    """Topologically order variables so deps come after their bases.
    Variables that reference unknown vars are treated as depending on nothing.
    """
    deps_map: dict[str, set[str]] = {k: find_dependencies(v) for k, v in variables.items()}
    # Keep only deps that are present in variables set
    all_names = set(variables.keys())
    deps_map = {k: {d for d in v if d in all_names} for k, v in deps_map.items()}

    indeg: dict[str, int] = {k: 0 for k in variables}
    graph: dict[str, set[str]] = defaultdict(set)
    for var, deps in deps_map.items():
        for d in deps:
            graph[d].add(var)
            indeg[var] += 1

    q: deque[str] = deque(sorted([k for k, deg in indeg.items() if deg == 0]))
    ordered: list[str] = []
    while q:
        u = q.popleft()
        ordered.append(u)
        for v in sorted(graph.get(u, [])):
            indeg[v] -= 1
            if indeg[v] == 0:
                q.append(v)

    # If any remain with indegree > 0 (cycles), append them deterministically
    remaining = [k for k, deg in indeg.items() if deg > 0]
    if remaining:
        ordered.extend(sorted(remaining))
    return ordered


def format_root(variables: dict[str, str]) -> str:
    # Identify groups
    main_names_pref = [
        '--pgn-color-primary-base',
        '--pgn-color-brand-base',
        '--pgn-color-secondary-base',
        '--pgn-color-info-base',
        '--pgn-color-success-base',
        '--pgn-color-warning-base',
        '--pgn-color-danger-base',
        '--pgn-color-black',
        '--pgn-color-white',
    ]
    present_main = [n for n in main_names_pref if n in variables]

    # Split base (no var()) vs derived (has var())
    base_vars = {k: v for k, v in variables.items() if 'var(' not in v}
    derived_vars = {k: v for k, v in variables.items() if 'var(' in v}

    ordered_all = topo_order(variables)

    # Build sections
    lines: list[str] = []
    lines.append('/* File generated by scripts/format_light_css.py */')
    lines.append(':root {')

    if present_main:
        lines.append('  /* ===== MAIN COLORS (easy to edit) ===== */')
        for name in present_main:
            lines.append(f'  {name}: {variables[name]};')
        lines.append('')

    # Base tokens (exclude ones already printed as main)
    lines.append('  /* ===== BASE TOKENS (no dependencies) ===== */')
    base_names = [n for n in ordered_all if n in base_vars and n not in present_main]
    for name in base_names:
        lines.append(f'  {name}: {variables[name]};')
    lines.append('')

    # Derived tokens
    lines.append('  /* ===== DERIVED TOKENS (use var()) ===== */')
    derived_names = [n for n in ordered_all if n in derived_vars and n not in present_main]
    for name in derived_names:
        lines.append(f'  {name}: {variables[name]};')

    lines.append('}')
    return '\n'.join(lines) + '\n'


def pretty_print_rules(css_rest: str) -> str:
    # Preserve sourceMappingURL and other trailing comments
    # Extract and keep trailing comment lines
    trailing = ''
    if '/*# sourceMappingURL=' in css_rest:
        idx = css_rest.rfind('/*# sourceMappingURL=')
        trailing = css_rest[idx:]
        css_rest = css_rest[:idx]

    rule_re = re.compile(r'([^{}]+)\{([^{}]*)\}')
    out_lines: list[str] = []
    out_lines.append('\n/* ===== THEME RULES (formatted) ===== */')
    pos = 0
    for m in rule_re.finditer(css_rest):
        selector = m.group(1).strip()
        body = m.group(2).strip()
        if not selector:
            continue
        out_lines.append(f'{selector} {{')
        if body:
            props = [p.strip() for p in body.split(';') if p.strip()]
            for p in props:
                out_lines.append(f'  {p};')
        out_lines.append('}\n')
        pos = m.end()

    # Append any remainder and trailing mapping comment
    remainder = css_rest[pos:].strip()
    if remainder:
        out_lines.append('/* Unparsed remainder (kept as-is) */')
        out_lines.append(remainder)
    if trailing:
        out_lines.append(trailing)
    return '\n'.join(out_lines) + '\n'


def main():
    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    in_path = os.path.join(repo_root, 'docs', 'paragon', 'themes', 'light.min.css')
    out_path = os.path.join(repo_root, 'docs', 'paragon', 'themes', 'light.formatted.css')

    if len(sys.argv) >= 2:
        in_path = sys.argv[1]
    if len(sys.argv) >= 3:
        out_path = sys.argv[2]

    css = read_file(in_path)
    before, root_inside, after = extract_root_block(css)
    if not root_inside:
        print('No :root block found; copying file as-is.')
        write_file(out_path, css)
        return

    variables = parse_variables(root_inside)
    formatted_root = format_root(variables)
    formatted_rules = pretty_print_rules(after)

    result = []
    result.append('/* ===== Paragon Light Theme (formatted) ===== */')
    result.append(formatted_root)
    result.append(formatted_rules)
    write_file(out_path, '\n'.join(result))
    print(f'Wrote formatted CSS to: {out_path}')
    print(f'Variables found: {len(variables)}')


if __name__ == '__main__':
    main()


